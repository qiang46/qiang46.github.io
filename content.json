{"meta":{"title":"qiang's blog","subtitle":null,"description":"坚持是一种风格","author":"qiang","url":"http://yoursite.com"},"pages":[{"title":"about","date":"2018-05-23T08:38:51.000Z","updated":"2018-05-23T08:38:51.754Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":""},{"title":"categories","date":"2018-05-23T06:19:12.000Z","updated":"2018-05-23T06:19:26.525Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2018-05-23T06:17:51.000Z","updated":"2018-05-23T06:18:55.146Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"webpack","slug":"webpack","date":"2018-06-04T06:46:56.000Z","updated":"2018-06-04T07:00:19.351Z","comments":true,"path":"2018/06/04/webpack/","link":"","permalink":"http://yoursite.com/2018/06/04/webpack/","excerpt":"","text":"webpack的安装使用webpack首先需要安装nodejs，让后在本地电脑上配置webpack。使用webpack需要在本地安装webpack。 安装全局webpack使用 npm 安装 webpack npm install webpack -g 将webpack安装到全局，此时可以使用webpack -h命令查看webpack的相关信息。 ##将webpack安装到实际的项目中实际开发中我们会将webpack安装到实际的项目中，这样就可以使用项目本地版本的webpack。 npm install webpack –save -dev 安装之前确保项目以及拥有package.json，如果没有使用npm init创建，或者自己手动创建。 安装指定版本的webpack如果需要安装指定版本的webpack可以使用npm info webpack查看webpack的版本信息，在使用 npm install webpack@2.7.0 –save -dev 上面的就是安装的2.7.0版本的webpack。 webpack的使用自己的代码已经放在了https://github.com/Anthony-Wilson/webpack上。使用以下命令可以使用webpack打包一个文件 webpack index.js bundle.js 上面的代码的意思是：把index.js及其所需要的依赖项打包到bundle.js。在实际使用的时候就是使用的bundle.js。 index.js没有内容的使用bundle.js也是有内容的，是一些webpack的基本配置。下面是webpack3.10.0这个版本的打包默认内容。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273/******/ (function(modules) &#123; // webpackBootstrap/******/ // The module cache/******/ var installedModules = &#123;&#125;;/******//******/ // The require function/******/ function __webpack_require__(moduleId) &#123;/******//******/ // Check if module is in cache/******/ if(installedModules[moduleId]) &#123;/******/ return installedModules[moduleId].exports;/******/ &#125;/******/ // Create a new module (and put it into the cache)/******/ var module = installedModules[moduleId] = &#123;/******/ i: moduleId,/******/ l: false,/******/ exports: &#123;&#125;/******/ &#125;;/******//******/ // Execute the module function/******/ modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);/******//******/ // Flag the module as loaded/******/ module.l = true;/******//******/ // Return the exports of the module/******/ return module.exports;/******/ &#125;/******//******//******/ // expose the modules object (__webpack_modules__)/******/ __webpack_require__.m = modules;/******//******/ // expose the module cache/******/ __webpack_require__.c = installedModules;/******//******/ // define getter function for harmony exports/******/ __webpack_require__.d = function(exports, name, getter) &#123;/******/ if(!__webpack_require__.o(exports, name)) &#123;/******/ Object.defineProperty(exports, name, &#123;/******/ configurable: false,/******/ enumerable: true,/******/ get: getter/******/ &#125;);/******/ &#125;/******/ &#125;;/******//******/ // getDefaultExport function for compatibility with non-harmony modules/******/ __webpack_require__.n = function(module) &#123;/******/ var getter = module &amp;&amp; module.__esModule ?/******/ function getDefault() &#123; return module['default']; &#125; :/******/ function getModuleExports() &#123; return module; &#125;;/******/ __webpack_require__.d(getter, 'a', getter);/******/ return getter;/******/ &#125;;/******//******/ // Object.prototype.hasOwnProperty.call/******/ __webpack_require__.o = function(object, property) &#123; return Object.prototype.hasOwnProperty.call(object, property); &#125;;/******//******/ // __webpack_public_path__/******/ __webpack_require__.p = \"\";/******//******/ // Load entry module and return exports/******/ return __webpack_require__(__webpack_require__.s = 0);/******/ &#125;)/************************************************************************//******/ ([/* 0 *//***/ (function(module, exports) &#123;/***/ &#125;)/******/ ]); 输出日志打包时会有一些日志 PS G:\\webpack\\demo1&gt; webpack index.js bundle.jsHash: 0bd4f09244f0e8c60354Version: webpack 3.10.0Time: 79ms Asset Size Chunks Chunk Namesbundle.js 2.47 kB 0 [emitted] main [0] ./index.js 0 bytes {0} [built] 其中： Hash：表示当前打包的一个记录名字 Version：表示当前webpack的版本 Time：表示打包所消耗的时间 bundle.js：表示的是打包后的文件，下面的[0]-[n]表示的是需要打包的文件及其信息。 webpack配置文件在具体的项目中我们是不会这个做的。而是创建一个webpack的配置文件。将需要的东西直接放入配置文件中。 下面来看看webpack的配置文件 创建一个配置文件在项目根目录下创建一个名字为webpack.config.js的js文件。这个文件的基本结构如下： module.exports = { } 这个文件是可以高度配置的，可以配置的有四个核心。 入口 entry 输出 output loader 插件 plugins 配置入口 entry入口起点(entry point)指示 webpack 应该使用哪个模块，来作为构建其内部依赖图的开始。进入入口起点后，webpack 会找出有哪些模块和库是入口起点（直接和间接）依赖的。简单的说就是那些文件是需要打包的。可以配置多个入口文件 下面是单文件的配置 123module.exports = &#123; entry: \"./index.js\"&#125; 如果是拥有多个文件可以使用数组或者是对象的方式 123module.exports = &#123; entry: [\"./index1.js\",\"./index2.js\"]&#125; 或者对象： 123456module.exports = &#123; entry: &#123; a: \"index1.js\", b: \"index2.js\" &#125;&#125; 如果是使用的多个入口文件，则表示他们之间没有相互依赖。 配置出口 outputoutput 属性告诉 webpack 在哪里输出它所创建的 bundles，以及如何命名这些文件。 1234567module.exports = &#123; entry: \"./index.js\", output: &#123; path: __dirname, filename: \"bundle.js\" &#125;&#125; 指定的output.path表示的输出目录的绝对路径，output.filename表示输出文件的名字。__dirname表示的是根目录 上面的都是单文件对应的入口与出口，如果是多文件则可以使用一下的代码： 12345678910module.exports = &#123; entry: &#123; app: \"./index.js\", module1: \"./js/module1.js\" &#125;, output: &#123; path: __dirname + \"/public\", filename: \"[name].js\" &#125;&#125; 上面的代码的意思是：有两个入口文件，一个是app，一个是module1。在配置出口文件的时候path指定的是根目录下面的public文件夹。filename使用的是[name].js。这里的[name]表示的是entry中的每一项，即app与mudule1两个。所以最后生成的就是两个js文件。一个app.js一个module1.js。在最开始的时候我们看的每一次打包的时候都会有一个hash，所以在生成js文件的时候有的开发者也可能会使用这个hash来命名。如下： 12345678910module.exports = &#123; entry: &#123; app: \"./index.js\", module1: \"./js/module1.js\" &#125;, output: &#123; path: __dirname + \"/public\", filename: \"[name]-[hash].js\" &#125;&#125; 之后生成的js文件的文件名就是app-hash的一个格式。但是要注意不能只是用hash。 当然，我们也可以利用这个hash创建一个文件夹。讲每一次的文件放在这和文件夹里面12345678910module.exports = &#123;entry: &#123;app: \"./index.js\",module1: \"./js/module1.js\"&#125;,output: &#123;path: __dirname + \"/public/[hash]\",filename: \"[name].js\"&#125;&#125; 可以看出，在这个配置文件里面如果需要使用一些”变量”可以用[]括起来配置了入口与出口后就可以使用这个文件了。在命令行使用webpack。这样也可以达到我们需要的目的。 为了方便。我们可以在package.json里面重新配置运行命令，下面我们把运行命令改为npm start。 1234\"scripts\": &#123; \"test\": \"\", \"start\": \"webpack\"&#125; 将package.json中的scripts中添加一个start，后面的值表示这个start所表示的命令。 以上就是关于输入与输出的配置配置loaderloader 用于对模块的源代码进行转换。loader 可以使你在import或”加载”模块时预处理文件。因此，loader 类似于其他构建工具中“任务(task)”，并提供了处理前端构建步骤的强大方法。loader 可以将文件从不同的语言（如 TypeScript）转换为 JavaScript，或将内联图像转换为 data URL。loader 甚至允许你直接在 JavaScript 模块中importCSS文件！上面的是webpack官网中的说法。简言之，就是使用loader把一些语法转换为现代浏览器支持的语法，并把他一起打包到你所需要的js文件里面。 使用最多的就是对css解析的loader，解析css需要安装两个loader：style-loader与css-loader那首先需要安装两个loader npm install style-loader –save -devnpm install css-loader –save -dev 配置的时候 12345678910111213141516171819202122232425module.exports = &#123; entry: &#123; app: \"./app.js\" &#125;, output: &#123; path: __dirname + \"/dist\", filename: \"[name].js\" &#125;, module: &#123; rules: [ &#123; test:/.css$/, use: [ &#123;loader: \"style-loader\"&#125;, &#123; loader: \"css-loader\", options: &#123; modules: true &#125; &#125; ] &#125; ] &#125;&#125; loader需要放在module的rules里面，rules是一个数组，里面放着每一个需要匹配的东西 text：表示的是需要匹配的文件，用正则匹配.css的文件 use：是一个数组，放着匹配这类文件需要用到的loader。 更多的配置查看https://doc.webpack-china.org/configuration/module/ 这是放在了webpack的配置文件里面，还可以在导入每一个文件的时候使用 require(“style-loader!css-loader?./style.css”)import Styles from ‘style-loader!css-loader?modules!./styles.css’; 或任何等效于 “import” 的方式中指定 loader。使用 ! 将资源中的 loader 分开。分开的每个部分都相对于当前目录解析。不过还是建议把loader的使用放在webpack的配置文件中，避免每一次都引用。 常用的loader： style-loader，css-loader：一起使用解析css postcss-loader：css的兼容处理（兼容性前缀） url-loader，file-loader：限制图片的大小 babel-loader，babel-preset-es2015，babel-preset-reace：js处理，js转码 less-loader，sass-loader：处理样式 json-loader：解析json格式文件 更多loader及说明查看：https://doc.webpack-china.org/loaders/ 配置插件（plugins）插件是 wepback 的支柱功能。webpack 自身也是构建于，你在 webpack 配置中用到的相同的插件系统之上！ 插件目的在于解决 loader 无法实现的其他事。 插件的配置也是在webpack的配置文件中，属性是plugins，值是一个数组。每个插件的使用需要单独去了解。 由于插件可以携带参数/选项，你必须在 webpack 配置中，向 plugins 属性传入new 实例。 使用html-webpack-plugin 123456789101112131415161718192021222324252627282930313233// 引入插件const HTMLWebpackPlugin = require(\"html-webpack-plugin\"); module.exports = &#123; entry: &#123; app: \"./app.js\" &#125;, output: &#123; path: __dirname + \"/dist\", filename: \"[name].js\" &#125;, module: &#123; rules: [ &#123; test:/.css$/, use: [ &#123;loader: \"style-loader\"&#125;, &#123; loader: \"css-loader\", options: &#123; modules: true &#125; &#125; ] &#125; ] &#125;, plugins: [ new HTMLWebpackPlugin(&#123; template: \"./template/index.html\" &#125;) ]&#125; 更多plugin及说明查看：https://doc.webpack-china.org/plugins/ 使用webpack-dev-server热更新webpack-dev-server是一个独立的模块，须有单独使用npm安装。 npm install webpack-dev-server –save -dev 让后在自己的package.json的scripts中添加 12345\"scripts\": &#123; \"test\": \"echo \\\"Error: no test specified\\\" &amp;&amp; exit 1\", \"start\": \"webpack\", \"dev\": \"webpack-dev-server --devtool eval-source-map --progress --colors --hot --inline --content-base ./dist\"&#125; 启用热更新须有使用npm run dev。后面的./dist表示热更新的文件目录。","categories":[],"tags":[{"name":"webpack","slug":"webpack","permalink":"http://yoursite.com/tags/webpack/"}]},{"title":"字符串-数组方法","slug":"string","date":"2018-05-22T07:53:49.000Z","updated":"2018-05-23T06:22:10.901Z","comments":true,"path":"2018/05/22/string/","link":"","permalink":"http://yoursite.com/2018/05/22/string/","excerpt":"","text":"一、字符串方法1、length[] 和 charAt()注意字符串的这两个方法只读不可写charCodeAt()String.fromCharCode()indexOf / lastIndexOfsubstring用法 str.substring(start , end) ，从start截取到end，不包括endstart/end最小值为0，即使小于0也为0start &gt; end时，交换位置获取 substring(end , start)slice和substring用法一样start / end可以为负值，负值时，倒着从最后数start 和 end任何时候都不会交换位置，能截取才有值，截取不到则无值toUpperCase() / toLowerCase()split() 二、数组方法length []可读可写push() unshift() pop() shift()他们的返回值splice( index , num , info )index：索引（包括） num：个数 info：替换内容（可以是多个参数，可以没有）arr.splice(0,2); //从第0个开始删除2个arr.splice(0,1,”清心”); //从第0个开始删除1个，并在当前位置添加 “清心”arr.splice(2,0,”清心”); //从第2个开始删除0个，并在当前位置添加”清心”sort()默认字符编码排序，若有数字会以字符的形式排序可以使用匿名函数加return排序倒序使用： arr.reverse()concat()join()filter过滤接收匿名函数加return的形式，该函数接收一个形参，代表序号，需返回一个布尔值判断是不是数组Array.isArray( ) //返回一个布尔值","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"git命令大全","slug":"postName","date":"2018-05-21T09:53:35.000Z","updated":"2018-05-23T06:22:10.900Z","comments":true,"path":"2018/05/21/postName/","link":"","permalink":"http://yoursite.com/2018/05/21/postName/","excerpt":"","text":"一、 Git 命令初识在正式介绍Git命令之前，先介绍一下Git 的基本命令和操作，对Git命令有一个总体的认识 示例：从Git 版本库的初始化，通常有两种方式： 1）git clone：这是一种较为简单的初始化方式，当你已经有一个远程的Git版本库，只需要在本地克隆一份；例如：git clone git://github.com/someone/some_project.git some_project； 上面的命令就是将’git://github.com/someone/some_project.git’这个URL地址的远程版本库，完全克隆到本地s ome_project目录下 2）git init 和 git remote：这种方式稍微复杂一些，当你本地创建了一个工作目录，你可以进入这个目录，使 用’git init’命令进行初始化；Git以后就会对该目录下的文件进行版本控制，这时候如果你需要将它放到远程服 务器上，可以在远程服务器上创建一个目录，并把可访问的URL记录下来，此时你就可以利用’git remote ad d’命令来增加一个远程服务器端。例如：git remote add origin git://github.com/someone/another_project.git 上面的命令就会增加URL地址为’git: //github.com/someone/another_project.git’，名称为origin的远程服务 器，以后提交代码的时候只需要使用 origin别名即可。 二、 Git 常用命令1) 远程仓库相关命令1234567891011121314检出仓库： $ git clone git://github.com/jquery/jquery.git；查看远程仓库：$ git remote -v；添加远程仓库：$ git remote add [name]；删除远程仓库：$ git remote rm [name]；修改远程仓库：$ git remote set-url --push [name] [newUrl]；拉取远程仓库：$ git pull [remoteName] [localBranchName]；推送远程仓库：$ git push [remoteName] [localBranchName]； *如果想把本地的某个分支test提交到远程仓库，并作为远程仓库的master分支，或者作为另外一个名叫test的 分支，如下： $git push origin test:master； // 提交本地test分支作为远程的master分支 $git push origin test:test ；// 提交本地test分支作为远程的test分支 2）分支(branch)操作相关命令查看本地分支：$ git branch； 查看远程分支：$ git branch -r； 创建本地分支：$ git branch [name]； —-注意新分支创建后不会自动切换为当前分支 切换分支：$ git checkout [name]； 创建新分支并立即切换到新分支：$ git checkout -b [name]； 删除分支：$ git branch -d [name] —- -d选项只能删除已经参与了合并的分支，对于未有合并的支是无法删 除的。如果想强制删除一个分支，可以使用-D选项 合并分支：$ git merge [name]； —-将名称为[name]的分支与当前分支合并 创建远程分支(本地分支push到远程)：$ git push origin [name]； 删除远程分支：$ git push origin :heads/[name] 或 $ gitpush origin :[name]； *创建空的分支：(执行命令之前记得先提交你当前分支的修改，否则会被强制删干净没得后悔) $git symbolic-ref HEAD refs/heads/[name]； $rm .git/index； $git clean -fdx； 3）版本(tag)操作相关命令查看版本：$ git tag； 创建版本：$ git tag [name]； 删除版本：$ git tag -d [name]； 查看远程版本：$ git tag -r； 创建远程版本(本地版本push到远程)：$ git push origin [name]； 删除远程版本：$ git push origin :refs/tags/[name]； 合并远程仓库的tag到本地：$ git pull origin –tags； 上传本地tag到远程仓库：$ git push origin –tags； 创建带注释的tag：$ git tag -a [name] -m ‘yourMessage’； 4) 子模块(submodule)相关操作命令添加子模块：$ git submodule add [path]；如：$git submodule add git://github.com/soberh/ui-libs.git src/main/webapp/ui-libs； 初始化子模块：$ git submodule init —-只在首次检出仓库时运行一次就行 更新子模块：$ git submodule update —-每次更新或切换分支后都需要运行一下 删除子模块：（分4步走哦） 1) $ git rm –cached [path]； 2) 编辑“.gitmodules”文件，将子模块的相关配置节点删除掉 3) 编辑“ .git/config”文件，将子模块的相关配置节点删除掉 4) 手动删除子模块残留的目录 5）忽略一些文件、文件夹不提交 在仓库根目录下创建名称为“.gitignore”的文件，写入不需要的文件夹名或文件，每个元素占一行即可，如 target； bin； *.db；","categories":[],"tags":[]}]}